# Vue.js Руководство по рендерингу на стороне сервера

::: tip ПРИМЕЧАНИЕ Для этого руководства требуются следующие минимальные версии Vue и поддерживающие библиотеки:

- vue & vue-server-renderer 2.3.0+
- vue-router 2.5.0+
- vue-loader 12.0.0+ и vue-style-loader 3.0.0+

Если вы ранее использовали Vue 2.2 с SSR, вы заметите, что рекомендуемая структура кода теперь [немного отличается](./guide/structure.md) (с новой опцией [runInNewContext,](./api/README.md#runinnewcontext) установленной в `false` ). Ваше существующее приложение должно продолжать работать, но рекомендуется перейти на новые рекомендации. :::

## Что такое рендеринг на стороне сервера (SSR)?

Vue.js - это фреймворк для создания клиентских приложений. По умолчанию компоненты Vue создают и обрабатывают DOM в браузере в качестве вывода. Тем не менее, также возможно преобразовать те же компоненты в строки HTML на сервере, отправить их непосредственно в браузер и, наконец, «гидрировать» статическую разметку в полностью интерактивное приложение на клиенте.

Привет мир! 1

## Так как

## Почему ССР?

По сравнению с традиционным SPA (одностраничное приложение) преимущество SSR заключается, прежде всего, в:

Привет мир! 2

- Лучшее SEO, так как сканеры поисковых систем будут непосредственно видеть полностью отображаемую страницу.

    Обратите внимание, что на данный момент Google и Bing могут индексировать синхронные приложения JavaScript просто отлично. Синхронное время является ключевым словом там. Если ваше приложение запускается с загрузчиком, а затем загружает контент через Ajax, сканер не будет ждать, пока вы закончите. Это означает, что если у вас есть контент, извлекаемый асинхронно на страницах, где важен SEO, SSR может понадобиться.

- Более быстрое время для контента, особенно на медленном интернете или медленных устройствах. Разметка, отображаемая на сервере, не должна ждать, пока весь JavaScript будет загружен и выполнен для отображения, поэтому ваш пользователь увидит полностью визуализированную страницу раньше. Как правило, это приводит к улучшению взаимодействия с пользователем и может быть критичным для приложений, в которых время до контента напрямую связано с коэффициентом конверсии.

Есть также некоторые компромиссы, которые следует учитывать при использовании SSR:

- Ограничения развития. Специфичный для браузера код может использоваться только внутри определенных хуков жизненного цикла; некоторые внешние библиотеки могут нуждаться в особой обработке для запуска в приложении, отображаемом на сервере.

- Более сложные требования к настройке сборки и развертыванию. В отличие от полностью статического SPA, который можно развернуть на любом статическом файловом сервере, для приложения, отображаемого на сервере, требуется среда, в которой может работать сервер Node.js.

- Больше серверной нагрузки. Рендеринг полноценного приложения в Node.js, очевидно, будет более ресурсоемким, чем просто обработка статических файлов, поэтому, если вы ожидаете большой трафик, будьте готовы к соответствующей загрузке сервера и разумно используйте стратегии кэширования.

Прежде чем использовать SSR для своего приложения, первый вопрос, который вы должны задать, - действительно ли он вам нужен. Это в основном зависит от того, насколько важно время для контента для вашего приложения. Например, если вы создаете внутреннюю панель инструментов, где дополнительные несколько сотен миллисекунд при начальной загрузке не имеют большого значения, SSR будет излишним. Однако в тех случаях, когда время для контента является абсолютно критическим, SSR может помочь вам достичь максимально возможной производительности начальной загрузки.

## SSR vs Prerendering

Если вы только расследование SSR для улучшения SEO кучки маркетинга страниц (например , `/` , `/about` , `/contact` , и т.д.), то вы , вероятно , хотите вместо **предварительной визуализации.** Вместо того, чтобы использовать веб-сервер для компиляции HTML на лету, предварительный рендеринг просто генерирует статические файлы HTML для определенных маршрутов во время сборки. Преимущество заключается в том, что настройка предварительного рендеринга намного проще и позволяет сохранить ваш веб-интерфейс как полностью статичный сайт.

Если вы используете веб-пакет, вы можете легко добавить предварительный рендеринг с помощью prerender [-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin) . Он был тщательно протестирован с приложениями Vue - и фактически, [создатель](https://github.com/chrisvfritz) является членом основной команды Vue.

## Об этом руководстве

Это руководство ориентировано на серверные одностраничные приложения, использующие Node.js в качестве сервера. Смешивание Vue SSR с другими настройками бэкэнда является отдельной темой и кратко обсуждается в отдельном [разделе](./guide/non-node.md) .

This guide will be very in-depth and assumes you are already familiar with Vue.js itself, and have decent working knowledge of Node.js and webpack. If you prefer a higher-level solution that provides a smooth out-of-the-box experience, you should probably give [Nuxt.js](https://nuxtjs.org/) a try. It's built upon the same Vue stack but abstracts away a lot of the boilerplate, and provides some extra features such as static site generation. However, it may not suit your use case if you need more direct control of your app's structure. Regardless, it would still be beneficial to read through this guide to better understand how things work together.

As you read along, it would be helpful to refer to the official [HackerNews Demo](https://github.com/vuejs/vue-hackernews-2.0/), which makes use of most of the techniques covered in this guide.

Наконец, обратите внимание, что решения в этом руководстве не являются окончательными - мы обнаружили, что они хорошо работают для нас, но это не значит, что их нельзя улучшить. Они могут быть пересмотрены в будущем - и не стесняйтесь вносить свой вклад, отправляя запросы на извлечение!
